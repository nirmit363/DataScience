# -*- coding: utf-8 -*-
"""Module 10.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zfTzr7UkMYMPOS58ZTmgqjksgSmB8WNL

1:
"""

# def keyword is used to create a function

def odd_numbers():
    odd_list = []
    for i in range(1,25):
        if i%2 != 0:
            odd_list.append(i)
    return odd_list

odd_numbers()

"""2:"""

# *args allows a function to accept a variable number of non-keyword arguments.
def print_args(*args):
  """Prints all arguments passed to the function."""
  for arg in args:
    print(arg)

# **kwargs allows a function to accept a variable number of keyword arguments.
def print_kwargs(**kwargs):
  """Prints all keyword arguments passed to the function."""
  for key, value in kwargs.items():
    print(f"{key}: {value}")

print_args(1,34,45,344.4,'Good')
print_kwargs(name='John', age=30, city='New York')

"""3:"""

# An iterator in Python is an object that implements the iterator protocol, which consists of the __iter__() and __next__() methods.
# The __iter__() method is used to initialize the iterator object, and the __next__() method is used for iteration.

my_list = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]

my_iterator = iter(my_list)

for _ in range(5):
    try:
        element = next(my_iterator)
        print(element)
    except StopIteration:
        print("End of iteration")
        break

"""4:"""

# A generator function in Python is a special type of function that returns an iterator.
# Unlike normal functions that return a value and then terminate, generator functions use the 'yield' keyword to produce a sequence of values one at a time, pausing execution between each value.
# This makes them memory-efficient for generating large sequences, as they don't need to store the entire sequence in memory at once.

# The 'yield' keyword is used in generator functions to indicate where the function should pause its execution and return a value to the caller.  When the generator is called again, it resumes from where it left off, maintaining its internal state.

def even_numbers_generator(limit):
    for i in range(0, limit + 1, 2):
        yield i

even_gen = even_numbers_generator(10)

for num in even_gen:
  print(num)

"""5:"""

import math

def prime_generator(limit):
    """
    Generates prime numbers less than a given limit.
    """
    primes = []
    for num in range(2, limit):
        is_prime = True
        for i in range(2, int(math.sqrt(num)) + 1):
            if num % i == 0:
                is_prime = False
                break
        if is_prime:
            primes.append(num)
            yield num


prime_gen = prime_generator(1000)

for _ in range(20):
    try:
        print(next(prime_gen))
    except StopIteration:
        print("No more prime numbers within the limit")
        break